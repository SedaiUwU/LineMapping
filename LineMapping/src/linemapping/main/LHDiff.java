package linemapping.main;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

import linemapping.model.LineMapObject;

public class LHDiff {

	static int KCANDIDATES = 15;
	static double MATCHTHRESHOLD = 0.45;
	static int MAXHAMMINGDISTANCE = 9;

	public static void main(String[] args) {
		if (args.length < 3) {
			System.err.println("Usage: <oldFile> <newFile> <outputFile>");
			System.exit(1);
		}

		String oldFilePath = args[0];
		String newFilePath = args[1];
		String outputPath = args[2];

		try {
			LineMapObject oldFile = new LineMapObject(oldFilePath);
			LineMapObject newFile = new LineMapObject(newFilePath);

			// Step 1 Preprocessing done in LineMapObject
			// Step 2 Detect unchanged
			DetectUnchangedLines detector = new DetectUnchangedLines(oldFile, newFile);
			detector.findUnchanged();

			// Add Unchanged lines to allmappings
			Map<Integer, Integer> allMappings = new HashMap<>(detector.getUnchanged());

			// Step 3 Map changed lines using SimHash candidates
			// Step 4 Apply hybrid scoring to candidates generated by simhash

			List<Integer> changedLeft = detector.getChangedLeft();
			List<Integer> changedRight = detector.getChangedRight();

			for (int leftIndex : changedLeft) {
				// Get SimHash candidates from changedRight
				List<Integer> candidates = getSimHashCandidates(leftIndex, changedRight, oldFile, newFile);

				double bestScore = 0;
				int bestMatch = -1;

				for (int rightIndex : candidates) {
					double score = calculateHybridScore(leftIndex, rightIndex, oldFile, newFile);
					if (score > bestScore && score > MATCHTHRESHOLD) {
						bestScore = score;
						bestMatch = rightIndex;
					}
				}

				if (bestMatch != -1) {

					List<Integer> splitGroup = detectSplitMapping(leftIndex, bestMatch, oldFile, newFile);

					if (splitGroup.size() > 1) {
						allMappings.put(leftIndex, splitGroup.get(0));
					} else {
						allMappings.put(leftIndex, bestMatch);
					}
				}
			}

			exportMapping(allMappings, oldFile, newFile, outputPath);

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private static List<Integer> getSimHashCandidates(int leftIndex, List<Integer> changedRight, LineMapObject leftFile,
			LineMapObject rightFile) {
		List<Integer> candidates = new ArrayList<>();
		long leftHash = SimHash.compute(leftFile.GetFixedLine(leftIndex));

		for (int rightIndex : changedRight) {
			long rightHash = SimHash.compute(rightFile.GetFixedLine(rightIndex));
			int hammingDist = SimHash.hammingDistance(leftHash, rightHash);

			if (hammingDist <= MAXHAMMINGDISTANCE && candidates.size() < KCANDIDATES) {
				candidates.add(rightIndex);
			}
		}

		// If not enough candidates then it will fill with remaining
		if (candidates.size() < KCANDIDATES) {
			for (int rightIndex : changedRight) {
				if (!candidates.contains(rightIndex) && candidates.size() < KCANDIDATES) {
					candidates.add(rightIndex);
				}
			}
		}

		return candidates;
	}

	private static double calculateHybridScore(int leftIndex, int rightIndex, LineMapObject leftFile, LineMapObject rightFile) {
		String lLine = leftFile.GetFixedLine(leftIndex);
		String rLine = rightFile.GetFixedLine(rightIndex);
		
		//assigning vec to compute cosine
		Map<String, Integer> vec1 = Cosine.getContextVector(leftIndex, leftFile);
		Map<String, Integer> vec2 = Cosine.getContextVector(rightIndex, rightFile);
		
		//applying the Levenshtein and Cosine methods
		double contentSim = Levenshtein.distance(lLine, rLine);
		double contextSim = Cosine.similarity(vec1, vec2);
		
		//used ratio as recomended from slides
		return (0.6 * contentSim) + (0.4 * contextSim);
	}
		// Line splitting method has been implemented
	private static List<Integer> detectSplitMapping(int leftIndex, int initialRightIndex,
			LineMapObject leftFile, LineMapObject rightFile) {

		List<Integer> group = new ArrayList<>();
		group.add(initialRightIndex);

		String left = leftFile.GetFixedLine(leftIndex);
		String combined = rightFile.GetFixedLine(initialRightIndex);

		double bestScore = Levenshtein.distance(left, combined);

		for (int next = initialRightIndex + 1; next < rightFile.GetSize(); next++) {

			String nextRight = rightFile.GetFixedLine(next);
			String newCombined = combined + " " + nextRight;

			double newScore = Levenshtein.distance(left, newCombined);

			if (newScore < bestScore) {
				group.add(next);
				combined = newCombined;
				bestScore = newScore;
			} else {
				break;
			}
		}

		return group;
	}

	private static void exportMapping(Map<Integer, Integer> mappings, LineMapObject oldFile, LineMapObject newFile,
			String outputPath) throws IOException {
		try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath))) {
			writer.write("oldLine ,newLine ");
			writer.newLine();

			for (Map.Entry<Integer, Integer> entry : mappings.entrySet()) {
				int oldIndex = entry.getKey();
				int newIndex = entry.getValue();

				int oldLineNum = oldIndex + 1;
				int newLineNum = newIndex + 1;

				String line = oldLineNum + "," + newLineNum;
				writer.write(line);
				writer.newLine();

				System.out.println("Old line " + oldLineNum + " -> New line " + newLineNum);
			}
		}
		 catch (IOException e) {
				e.printStackTrace();
			}
		System.out.println("Complete mapping written to: " + outputPath);
	}
}
